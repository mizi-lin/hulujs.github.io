import{a as Y}from"./react-c9cfb105.js";import{R as Er}from"./react-dom-26dc6dd6.js";function wr(e){const t=new Error(e);if(t.stack===void 0)try{throw t}catch{}return t}var Nr=wr,U=Nr;function Lr(e){return!!e&&typeof e.then=="function"}var K=Lr;function Vr(e,t){if(e!=null)return e;throw U(t??"Got unexpected null or undefined")}var Z=Vr;function M(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class gt{getValue(){throw U("BaseLoadable")}toPromise(){throw U("BaseLoadable")}valueMaybe(){throw U("BaseLoadable")}valueOrThrow(){throw U(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw U("BaseLoadable")}promiseOrThrow(){throw U(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw U("BaseLoadable")}errorOrThrow(){throw U(`Loadable expected error, but in "${this.state}" state`)}is(t){return t.state===this.state&&t.contents===this.contents}map(t){throw U("BaseLoadable")}}class Cr extends gt{constructor(t){super(),M(this,"state","hasValue"),M(this,"contents",void 0),this.contents=t}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(t){try{const n=t(this.contents);return K(n)?Le(n):Oe(n)?n:ot(n)}catch(n){return K(n)?Le(n.next(()=>this.map(t))):bt(n)}}}class $r extends gt{constructor(t){super(),M(this,"state","hasError"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(t){return this}}class Yn extends gt{constructor(t){super(),M(this,"state","loading"),M(this,"contents",void 0),this.contents=t}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(t){return Le(this.contents.then(n=>{const o=t(n);if(Oe(o)){const r=o;switch(r.state){case"hasValue":return r.contents;case"hasError":throw r.contents;case"loading":return r.contents}}return o}).catch(n=>{if(K(n))return n.then(()=>this.map(t).contents);throw n}))}}function ot(e){return Object.freeze(new Cr(e))}function bt(e){return Object.freeze(new $r(e))}function Le(e){return Object.freeze(new Yn(e))}function Xn(){return Object.freeze(new Yn(new Promise(()=>{})))}function Mr(e){return e.every(t=>t.state==="hasValue")?ot(e.map(t=>t.contents)):e.some(t=>t.state==="hasError")?bt(Z(e.find(t=>t.state==="hasError"),"Invalid loadable passed to loadableAll").contents):Le(Promise.all(e.map(t=>t.contents)))}function Jn(e){const n=(Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(r=>e[r])).map(r=>Oe(r)?r:K(r)?Le(r):ot(r)),o=Mr(n);return Array.isArray(e)?o:o.map(r=>Object.getOwnPropertyNames(e).reduce((a,s,l)=>({...a,[s]:r[l]}),{}))}function Oe(e){return e instanceof gt}const Ur={of:e=>K(e)?Le(e):Oe(e)?e:ot(e),error:e=>bt(e),loading:()=>Xn(),all:Jn,isLoadable:Oe};var Ce={loadableWithValue:ot,loadableWithError:bt,loadableWithPromise:Le,loadableLoading:Xn,loadableAll:Jn,isLoadable:Oe,RecoilLoadable:Ur},Ir=Ce.loadableWithValue,kr=Ce.loadableWithError,Dr=Ce.loadableWithPromise,Br=Ce.loadableLoading,Pr=Ce.loadableAll,Or=Ce.isLoadable,xr=Ce.RecoilLoadable,rt=Object.freeze({__proto__:null,loadableWithValue:Ir,loadableWithError:kr,loadableWithPromise:Dr,loadableLoading:Br,loadableAll:Pr,isLoadable:Or,RecoilLoadable:xr});const Jt={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};function Fr(e,t){var n,o;const r=(n=process.env[e])===null||n===void 0||(o=n.toLowerCase())===null||o===void 0?void 0:o.trim();if(r==null||r==="")return;if(!["true","false"].includes(r))throw U(`({}).${e} value must be 'true', 'false', or empty: ${r}`);t(r==="true")}function zr(e,t){var n;const o=(n=process.env[e])===null||n===void 0?void 0:n.trim();o==null||o===""||t(o.split(/\s*,\s*|\s+/))}function Wr(){var e;typeof process>"u"||((e=process)===null||e===void 0?void 0:e.env)!=null&&(Fr("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",t=>{Jt.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=t}),zr("RECOIL_GKS_ENABLED",t=>{t.forEach(n=>{Jt.RECOIL_GKS_ENABLED.add(n)})}))}Wr();var Ge=Jt;function Tt(e){return Ge.RECOIL_GKS_ENABLED.has(e)}Tt.setPass=e=>{Ge.RECOIL_GKS_ENABLED.add(e)};Tt.setFail=e=>{Ge.RECOIL_GKS_ENABLED.delete(e)};Tt.clear=()=>{Ge.RECOIL_GKS_ENABLED.clear()};var G=Tt;function Gr(e,t,{error:n}={}){return null}var Kr=Gr,cn=Kr,Gt,Kt,Ht;const Hr=(Gt=Y.createMutableSource)!==null&&Gt!==void 0?Gt:Y.unstable_createMutableSource,Qn=(Kt=Y.useMutableSource)!==null&&Kt!==void 0?Kt:Y.unstable_useMutableSource,eo=(Ht=Y.useSyncExternalStore)!==null&&Ht!==void 0?Ht:Y.unstable_useSyncExternalStore;function jr(){var e;const{ReactCurrentDispatcher:t,ReactCurrentOwner:n}=Y.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;return((e=t?.current)!==null&&e!==void 0?e:n.currentDispatcher).useSyncExternalStore!=null}function qr(){return G("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:G("recoil_sync_external_store")&&eo!=null?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:G("recoil_mutable_source")&&Qn!=null&&typeof window<"u"&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?G("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:G("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}function Zr(){return!1}var at={createMutableSource:Hr,useMutableSource:Qn,useSyncExternalStore:eo,currentRendererSupportsUseSyncExternalStore:jr,reactMode:qr,isFastRefreshEnabled:Zr};class ln{constructor(t){M(this,"key",void 0),this.key=t}toJSON(){return{key:this.key}}}class to extends ln{}class no extends ln{}function Yr(e){return e instanceof to||e instanceof no}var At={AbstractRecoilValue:ln,RecoilState:to,RecoilValueReadOnly:no,isRecoilValue:Yr},Xr=At.AbstractRecoilValue,Jr=At.RecoilState,Qr=At.RecoilValueReadOnly,ea=At.isRecoilValue,xe=Object.freeze({__proto__:null,AbstractRecoilValue:Xr,RecoilState:Jr,RecoilValueReadOnly:Qr,isRecoilValue:ea});function ta(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()}var Et=ta;class oo{}const na=new oo,Ve=new Map,un=new Map;function oa(e){return Et(e,t=>Z(un.get(t)))}function ra(e){if(Ve.has(e)){const t=`Duplicate atom key "${e}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;console.warn(t)}}function aa(e){Ge.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&ra(e.key),Ve.set(e.key,e);const t=e.set==null?new xe.RecoilValueReadOnly(e.key):new xe.RecoilState(e.key);return un.set(e.key,t),t}class ro extends Error{}function sa(e){const t=Ve.get(e);if(t==null)throw new ro(`Missing definition for RecoilValue: "${e}""`);return t}function ia(e){return Ve.get(e)}const St=new Map;function ca(e){var t;if(!G("recoil_memory_managament_2020"))return;const n=Ve.get(e);if(n!=null&&(t=n.shouldDeleteConfigOnRelease)!==null&&t!==void 0&&t.call(n)){var o;Ve.delete(e),(o=ao(e))===null||o===void 0||o(),St.delete(e)}}function la(e,t){G("recoil_memory_managament_2020")&&(t===void 0?St.delete(e):St.set(e,t))}function ao(e){return St.get(e)}var le={nodes:Ve,recoilValues:un,registerNode:aa,getNode:sa,getNodeMaybe:ia,deleteNodeConfigIfPossible:ca,setConfigDeletionHandler:la,getConfigDeletionHandler:ao,recoilValuesForKeys:oa,NodeMissingError:ro,DefaultValue:oo,DEFAULT_VALUE:na};function ua(e,t){t()}var da={enqueueExecution:ua};function fa(e,t){return t={exports:{}},e(t,t.exports),t.exports}var ha=fa(function(e){var t=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(c){return typeof c}:function(c){return c&&typeof Symbol=="function"&&c.constructor===Symbol&&c!==Symbol.prototype?"symbol":typeof c},n={},o=5,r=Math.pow(2,o),a=r-1,s=r/2,l=r/4,u={},f=function(i){return function(){return i}},_=n.hash=function(c){var i=typeof c>"u"?"undefined":t(c);if(i==="number")return c;i!=="string"&&(c+="");for(var h=0,R=0,m=c.length;R<m;++R){var g=c.charCodeAt(R);h=(h<<5)-h+g|0}return h},p=function(i){return i-=i>>1&1431655765,i=(i&858993459)+(i>>2&858993459),i=i+(i>>4)&252645135,i+=i>>8,i+=i>>16,i&127},C=function(i,h){return h>>>i&a},V=function(i){return 1<<i},y=function(i,h){return p(i&h-1)},E=function(i,h,R,m){var g=m;if(!i){var L=m.length;g=new Array(L);for(var w=0;w<L;++w)g[w]=m[w]}return g[h]=R,g},X=function(i,h,R){var m=R.length-1,g=0,L=0,w=R;if(i)g=L=h;else for(w=new Array(m);g<h;)w[L++]=R[g++];for(++g;g<=m;)w[L++]=R[g++];return i&&(w.length=m),w},ne=function(i,h,R,m){var g=m.length;if(i){for(var L=g;L>=h;)m[L--]=m[L];return m[h]=R,m}for(var w=0,N=0,k=new Array(g+1);w<h;)k[N++]=m[w++];for(k[h]=R;w<g;)k[++N]=m[w++];return k},A=1,P=2,ee=3,W=4,H={__hamt_isEmpty:!0},J=function(i){return i===H||i&&i.__hamt_isEmpty},se=function(i,h,R,m){return{type:A,edit:i,hash:h,key:R,value:m,_modify:Ie}},me=function(i,h,R){return{type:P,edit:i,hash:h,children:R,_modify:ke}},F=function(i,h,R){return{type:ee,edit:i,mask:h,children:R,_modify:O}},ae=function(i,h,R){return{type:W,edit:i,size:h,children:R,_modify:x}},Ee=function(i){return i===H||i.type===A||i.type===P},re=function(i,h,R,m,g){for(var L=[],w=m,N=0,k=0;w;++k)w&1&&(L[k]=g[N++]),w>>>=1;return L[h]=R,ae(i,N+1,L)},ue=function(i,h,R,m){for(var g=new Array(h-1),L=0,w=0,N=0,k=m.length;N<k;++N)if(N!==R){var q=m[N];q&&!J(q)&&(g[L++]=q,w|=1<<N)}return F(i,w,g)},Me=function c(i,h,R,m,g,L){if(R===g)return me(i,R,[L,m]);var w=C(h,R),N=C(h,g);return F(i,V(w)|V(N),w===N?[c(i,h+o,R,m,g,L)]:w<N?[m,L]:[L,m])},Ue=function(i,h,R,m,g,L,w,N){for(var k=g.length,q=0;q<k;++q){var ie=g[q];if(R(w,ie.key)){var oe=ie.value,he=L(oe);return he===oe?g:he===u?(--N.value,X(i,q,g)):E(i,q,se(h,m,w,he),g)}}var ve=L();return ve===u?g:(++N.value,E(i,k,se(h,m,w,ve),g))},ye=function(i,h){return i===h.edit},Ie=function(i,h,R,m,g,L,w){if(h(L,this.key)){var N=m(this.value);return N===this.value?this:N===u?(--w.value,H):ye(i,this)?(this.value=N,this):se(i,g,L,N)}var k=m();return k===u?this:(++w.value,Me(i,R,this.hash,this,g,se(i,g,L,k)))},ke=function(i,h,R,m,g,L,w){if(g===this.hash){var N=ye(i,this),k=Ue(N,i,h,this.hash,this.children,m,L,w);return k===this.children?this:k.length>1?me(i,this.hash,k):k[0]}var q=m();return q===u?this:(++w.value,Me(i,R,this.hash,this,g,se(i,g,L,q)))},O=function(i,h,R,m,g,L,w){var N=this.mask,k=this.children,q=C(R,g),ie=V(q),oe=y(N,ie),he=N&ie,ve=he?k[oe]:H,De=ve._modify(i,h,R+o,m,g,L,w);if(ve===De)return this;var ut=ye(i,this),He=N,je=void 0;if(he&&J(De)){if(He&=~ie,!He)return H;if(k.length<=2&&Ee(k[oe^1]))return k[oe^1];je=X(ut,oe,k)}else if(!he&&!J(De)){if(k.length>=s)return re(i,q,De,N,k);He|=ie,je=ne(ut,oe,De,k)}else je=E(ut,oe,De,k);return ut?(this.mask=He,this.children=je,this):F(i,He,je)},x=function(i,h,R,m,g,L,w){var N=this.size,k=this.children,q=C(R,g),ie=k[q],oe=(ie||H)._modify(i,h,R+o,m,g,L,w);if(ie===oe)return this;var he=ye(i,this),ve=void 0;if(J(ie)&&!J(oe))++N,ve=E(he,q,oe,k);else if(!J(ie)&&J(oe)){if(--N,N<=l)return ue(i,N,q,k);ve=E(he,q,H,k)}else ve=E(he,q,oe,k);return he?(this.size=N,this.children=ve,this):ae(i,N,ve)};H._modify=function(c,i,h,R,m,g,L){var w=R();return w===u?H:(++L.value,se(c,m,g,w))};function d(c,i,h,R,m){this._editable=c,this._edit=i,this._config=h,this._root=R,this._size=m}d.prototype.setTree=function(c,i){return this._editable?(this._root=c,this._size=i,this):c===this._root?this:new d(this._editable,this._edit,this._config,c,i)};var v=n.tryGetHash=function(c,i,h,R){for(var m=R._root,g=0,L=R._config.keyEq;;)switch(m.type){case A:return L(h,m.key)?m.value:c;case P:{if(i===m.hash)for(var w=m.children,N=0,k=w.length;N<k;++N){var q=w[N];if(L(h,q.key))return q.value}return c}case ee:{var ie=C(g,i),oe=V(ie);if(m.mask&oe){m=m.children[y(m.mask,oe)],g+=o;break}return c}case W:{if(m=m.children[C(g,i)],m){g+=o;break}return c}default:return c}};d.prototype.tryGetHash=function(c,i,h){return v(c,i,h,this)};var S=n.tryGet=function(c,i,h){return v(c,h._config.hash(i),i,h)};d.prototype.tryGet=function(c,i){return S(c,i,this)};var $=n.getHash=function(c,i,h){return v(void 0,c,i,h)};d.prototype.getHash=function(c,i){return $(c,i,this)},n.get=function(c,i){return v(void 0,i._config.hash(c),c,i)},d.prototype.get=function(c,i){return S(i,c,this)};var b=n.has=function(c,i,h){return v(u,c,i,h)!==u};d.prototype.hasHash=function(c,i){return b(c,i,this)};var B=n.has=function(c,i){return b(i._config.hash(c),c,i)};d.prototype.has=function(c){return B(c,this)};var D=function(i,h){return i===h};n.make=function(c){return new d(0,0,{keyEq:c&&c.keyEq||D,hash:c&&c.hash||_},H,0)},n.empty=n.make();var T=n.isEmpty=function(c){return c&&!!J(c._root)};d.prototype.isEmpty=function(){return T(this)};var j=n.modifyHash=function(c,i,h,R){var m={value:R._size},g=R._root._modify(R._editable?R._edit:NaN,R._config.keyEq,0,c,i,h,m);return R.setTree(g,m.value)};d.prototype.modifyHash=function(c,i,h){return j(h,c,i,this)};var te=n.modify=function(c,i,h){return j(c,h._config.hash(i),i,h)};d.prototype.modify=function(c,i){return te(i,c,this)};var z=n.setHash=function(c,i,h,R){return j(f(h),c,i,R)};d.prototype.setHash=function(c,i,h){return z(c,i,h,this)};var Q=n.set=function(c,i,h){return z(h._config.hash(c),c,i,h)};d.prototype.set=function(c,i){return Q(c,i,this)};var _e=f(u),we=n.removeHash=function(c,i,h){return j(_e,c,i,h)};d.prototype.removeHash=d.prototype.deleteHash=function(c,i){return we(c,i,this)};var fe=n.remove=function(c,i){return we(i._config.hash(c),c,i)};d.prototype.remove=d.prototype.delete=function(c){return fe(c,this)};var de=n.beginMutation=function(c){return new d(c._editable+1,c._edit+1,c._config,c._root,c._size)};d.prototype.beginMutation=function(){return de(this)};var An=n.endMutation=function(c){return c._editable=c._editable&&c._editable-1,c};d.prototype.endMutation=function(){return An(this)};var vr=n.mutate=function(c,i){var h=de(i);return c(h),An(h)};d.prototype.mutate=function(c){return vr(c,this)};var Ft=function(i){return i&&En(i[0],i[1],i[2],i[3],i[4])},En=function(i,h,R,m,g){for(;R<i;){var L=h[R++];if(L&&!J(L))return wn(L,m,[i,h,R,m,g])}return Ft(g)},wn=function(i,h,R){switch(i.type){case A:return{value:h(i),rest:R};case P:case W:case ee:var m=i.children;return En(m.length,m,0,h,R);default:return Ft(R)}},pr={done:!0};function zt(c){this.v=c}zt.prototype.next=function(){if(!this.v)return pr;var c=this.v;return this.v=Ft(c.rest),c},zt.prototype[Symbol.iterator]=function(){return this};var Wt=function(i,h){return new zt(wn(i._root,h))},Sr=function(i){return[i.key,i.value]},Rr=n.entries=function(c){return Wt(c,Sr)};d.prototype.entries=d.prototype[Symbol.iterator]=function(){return Rr(this)};var mr=function(i){return i.key},yr=n.keys=function(c){return Wt(c,mr)};d.prototype.keys=function(){return yr(this)};var gr=function(i){return i.value},br=n.values=d.prototype.values=function(c){return Wt(c,gr)};d.prototype.values=function(){return br(this)};var Nn=n.fold=function(c,i,h){var R=h._root;if(R.type===A)return c(i,R.value,R.key);for(var m=[R.children],g=void 0;g=m.pop();)for(var L=0,w=g.length;L<w;){var N=g[L++];N&&N.type&&(N.type===A?i=c(i,N.value,N.key):m.push(N.children))}return i};d.prototype.fold=function(c,i){return Nn(c,i,this)};var Tr=n.forEach=function(c,i){return Nn(function(h,R,m){return c(R,m,i)},null,i)};d.prototype.forEach=function(c){return Tr(c,this)};var Ar=n.count=function(c){return c._size};d.prototype.count=function(){return Ar(this)},Object.defineProperty(d.prototype,"size",{get:d.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n});class _a{constructor(t){M(this,"_map",void 0),this._map=new Map(t?.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(t){return this._map.get(t)}has(t){return this._map.has(t)}set(t,n){return this._map.set(t,n),this}delete(t){return this._map.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._map)}}class dn{constructor(t){if(M(this,"_hamt",ha.empty.beginMutation()),t instanceof dn){const n=t._hamt.endMutation();t._hamt=n.beginMutation(),this._hamt=n.beginMutation()}else if(t)for(const[n,o]of t.entries())this._hamt.set(n,o)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(t){return this._hamt.get(t)}has(t){return this._hamt.has(t)}set(t,n){return this._hamt.set(t,n),this}delete(t){return this._hamt.delete(t),this}clone(){return fn(this)}toMap(){return new Map(this._hamt)}}function fn(e){return G("recoil_hamt_2020")?new dn(e):new _a(e)}var va={persistentMap:fn},pa=va.persistentMap,Sa=Object.freeze({__proto__:null,persistentMap:pa});function Ra(e,...t){const n=new Set;e:for(const o of e){for(const r of t)if(r.has(o))continue e;n.add(o)}return n}var et=Ra;function ma(e,t){const n=new Map;return e.forEach((o,r)=>{n.set(r,t(o,r))}),n}var Rt=ma;function ya(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}}function ga(e){return{nodeDeps:Rt(e.nodeDeps,t=>new Set(t)),nodeToNodeSubscriptions:Rt(e.nodeToNodeSubscriptions,t=>new Set(t))}}function jt(e,t,n,o){const{nodeDeps:r,nodeToNodeSubscriptions:a}=n,s=r.get(e);if(s&&o&&s!==o.nodeDeps.get(e))return;r.set(e,t);const l=s==null?t:et(t,s);for(const u of l)a.has(u)||a.set(u,new Set),Z(a.get(u)).add(e);if(s){const u=et(s,t);for(const f of u){if(!a.has(f))return;const _=Z(a.get(f));_.delete(e),_.size===0&&a.delete(f)}}}function ba(e,t,n,o){var r,a,s,l;const u=n.getState();o===u.currentTree.version||o===((r=u.nextTree)===null||r===void 0?void 0:r.version)||((a=u.previousTree)===null||a===void 0||a.version);const f=n.getGraph(o);if(jt(e,t,f),o===((s=u.previousTree)===null||s===void 0?void 0:s.version)){const p=n.getGraph(u.currentTree.version);jt(e,t,p,f)}if(o===((l=u.previousTree)===null||l===void 0?void 0:l.version)||o===u.currentTree.version){var _;const p=(_=u.nextTree)===null||_===void 0?void 0:_.version;if(p!==void 0){const C=n.getGraph(p);jt(e,t,C,f)}}}var st={cloneGraph:ga,graph:ya,saveDepsToStore:ba};let Ta=0;const Aa=()=>Ta++;let Ea=0;const wa=()=>Ea++;let Na=0;const La=()=>Na++;var wt={getNextTreeStateVersion:Aa,getNextStoreID:wa,getNextComponentID:La};const{persistentMap:Ln}=Sa,{graph:Va}=st,{getNextTreeStateVersion:so}=wt;function io(){const e=so();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:Ln(),nonvalidatedAtoms:Ln()}}function Ca(){const e=io();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(e.version,Va()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}}var co={makeEmptyTreeState:io,makeEmptyStoreState:Ca,getNextTreeStateVersion:so};class lo{}function $a(){return new lo}var Nt={RetentionZone:lo,retentionZone:$a};function Ma(e,t){const n=new Set(e);return n.add(t),n}function Ua(e,t){const n=new Set(e);return n.delete(t),n}function Ia(e,t,n){const o=new Map(e);return o.set(t,n),o}function ka(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o}function Da(e,t){const n=new Map(e);return n.delete(t),n}function Ba(e,t){const n=new Map(e);return t.forEach(o=>n.delete(o)),n}var uo={setByAddingToSet:Ma,setByDeletingFromSet:Ua,mapBySettingInMap:Ia,mapByUpdatingInMap:ka,mapByDeletingFromMap:Da,mapByDeletingMultipleFromMap:Ba};function*Pa(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)}var hn=Pa;function Oa(e,t){return new Proxy(e,{get:(o,r)=>(!(r in o)&&r in t&&(o[r]=t[r]()),o[r]),ownKeys:o=>Object.keys(o)})}var fo=Oa;const{getNode:it,getNodeMaybe:xa,recoilValuesForKeys:Vn}=le,{RetentionZone:Cn}=Nt,{setByAddingToSet:Fa}=uo,za=Object.freeze(new Set);class Wa extends Error{}function Ga(e,t,n){if(!G("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(a){let s=o.get(a);s||o.set(a,s=new Set),s.add(t)}if(n instanceof Cn)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!G("recoil_memory_managament_2020"))return;const{retention:a}=e.getState();function s(l){const u=a.nodesRetainedByZone.get(l);u?.delete(t),u&&u.size===0&&a.nodesRetainedByZone.delete(l)}if(n instanceof Cn)s(n);else if(Array.isArray(n))for(const l of n)s(l)}}function _n(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=it(n),s=Ga(e,n,a.retainedBy),l=a.init(e,t,o);r.nodeCleanupFunctions.set(n,()=>{l(),s()})}function Ka(e,t,n){_n(e,e.getState().currentTree,t,n)}function Ha(e,t){var n;const o=e.getState();(n=o.nodeCleanupFunctions.get(t))===null||n===void 0||n(),o.nodeCleanupFunctions.delete(t)}function ja(e,t,n){return _n(e,t,n,"get"),it(n).get(e,t)}function ho(e,t,n){return it(n).peek(e,t)}function qa(e,t,n){var o;const r=xa(t);return r==null||(o=r.invalidate)===null||o===void 0||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:Fa(e.dirtyAtoms,t)}}function Za(e,t,n,o){const r=it(n);if(r.set==null)throw new Wa(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return _n(e,t,n,"set"),a(e,t,o)}function Ya(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=it(n).nodeType;return fo({type:a},{loadable:()=>ho(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>a==="selector"?!1:t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var s;return Vn((s=r.nodeDeps.get(n))!==null&&s!==void 0?s:[])},subscribers:()=>{var s,l;return{nodes:Vn(hn(_o(e,t,new Set([n])),u=>u!==n)),components:Et((s=(l=o.nodeToComponentSubscriptions.get(n))===null||l===void 0?void 0:l.values())!==null&&s!==void 0?s:[],([u])=>({name:u}))}}})}function _o(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let l=r.pop();l;l=r.pop()){var s;o.add(l);const u=(s=a.nodeToNodeSubscriptions.get(l))!==null&&s!==void 0?s:za;for(const f of u)o.has(f)||r.push(f)}return o}var Te={getNodeLoadable:ja,peekNodeLoadable:ho,setNodeValue:Za,initializeNode:Ka,cleanUpNode:Ha,setUnvalidatedAtomValue_DEPRECATED:qa,peekNodeInfo:Ya,getDownstreamNodes:_o};let vo=null;function Xa(e){vo=e}function Ja(){var e;(e=vo)===null||e===void 0||e()}var po={setInvalidateMemoizedSnapshot:Xa,invalidateMemoizedSnapshot:Ja};const{getDownstreamNodes:Qa,getNodeLoadable:So,setNodeValue:es}=Te,{getNextComponentID:ts}=wt,{getNode:ns,getNodeMaybe:Ro}=le,{DefaultValue:vn}=le,{reactMode:os}=at,{AbstractRecoilValue:rs,RecoilState:as,RecoilValueReadOnly:ss,isRecoilValue:is}=xe,{invalidateMemoizedSnapshot:cs}=po;function ls(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version===a.currentTree.version||n.version===((o=a.nextTree)===null||o===void 0?void 0:o.version)||(n.version,(r=a.previousTree)===null||r===void 0||r.version);const s=So(e,n,t);return s.state==="loading"&&s.contents.catch(()=>{}),s}function us(e,t){const n=e.clone();return t.forEach((o,r)=>{o.state==="hasValue"&&o.contents instanceof vn?n.delete(r):n.set(r,o)}),n}function ds(e,t,{key:n},o){if(typeof o=="function"){const r=So(e,t,n);if(r.state==="loading"){const a=`Tried to set atom or selector "${n}" using an updater function while the current state is pending, this is not currently supported.`;throw U(a)}else if(r.state==="hasError")throw r.contents;return o(r.contents)}else return o}function fs(e,t,n){if(n.type==="set"){const{recoilValue:r,valueOrUpdater:a}=n,s=ds(e,t,r,a),l=es(e,t,r.key,s);for(const[u,f]of l.entries())Qt(t,u,f)}else if(n.type==="setLoadable"){const{recoilValue:{key:r},loadable:a}=n;Qt(t,r,a)}else if(n.type==="markModified"){const{recoilValue:{key:r}}=n;t.dirtyAtoms.add(r)}else if(n.type==="setUnvalidated"){var o;const{recoilValue:{key:r},unvalidatedValue:a}=n,s=Ro(r);s==null||(o=s.invalidate)===null||o===void 0||o.call(s,t),t.atomValues.delete(r),t.nonvalidatedAtoms.set(r,a),t.dirtyAtoms.add(r)}else cn(`Unknown action ${n.type}`)}function Qt(e,t,n){n.state==="hasValue"&&n.contents instanceof vn?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function mo(e,t){e.replaceState(n=>{const o=yo(n);for(const r of t)fs(e,o,r);return go(e,o),cs(),o})}function Lt(e,t){if(tt.length){const n=tt[tt.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else mo(e,[t])}const tt=[];function hs(){const e=new Map;return tt.push(e),()=>{for(const[t,n]of e)mo(t,n);tt.pop()}}function yo(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function go(e,t){const n=Qa(e,t,t.dirtyAtoms);for(const a of n){var o,r;(o=Ro(a))===null||o===void 0||(r=o.invalidate)===null||r===void 0||r.call(o,t)}}function bo(e,t,n){Lt(e,{type:"set",recoilValue:t,valueOrUpdater:n})}function _s(e,t,n){if(n instanceof vn)return bo(e,t,n);Lt(e,{type:"setLoadable",recoilValue:t,loadable:n})}function vs(e,t){Lt(e,{type:"markModified",recoilValue:t})}function ps(e,t,n){Lt(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})}function Ss(e,{key:t},n,o=null){const r=ts(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),Z(a.nodeToComponentSubscriptions.get(t)).set(r,[o??"<not captured>",n]);const s=os();if(s.early&&(s.mode==="LEGACY"||s.mode==="MUTABLE_SOURCE")){const l=e.getState().nextTree;l&&l.dirtyAtoms.has(t)&&n(l)}return{release:()=>{const l=e.getState(),u=l.nodeToComponentSubscriptions.get(t);u===void 0||!u.has(r)||(u.delete(r),u.size===0&&l.nodeToComponentSubscriptions.delete(t))}}}function Rs(e,t){var n;const{currentTree:o}=e.getState(),r=ns(t.key);(n=r.clearCache)===null||n===void 0||n.call(r,e,o)}var Se={RecoilValueReadOnly:ss,AbstractRecoilValue:rs,RecoilState:as,getRecoilValueAsLoadable:ls,setRecoilValue:bo,setRecoilValueLoadable:_s,markRecoilValueModified:vs,setUnvalidatedRecoilValue:ps,subscribeToRecoilValue:Ss,isRecoilValue:is,applyAtomValueWrites:us,batchStart:hs,writeLoadableToTreeState:Qt,invalidateDownstreams:go,copyTreeState:yo,refreshRecoilValue:Rs};function ms(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1}var ys=ms;const{cleanUpNode:gs}=Te,{deleteNodeConfigIfPossible:bs,getNode:To}=le,{RetentionZone:Ao}=Nt,Ts=12e4,Eo=new Set;function wo(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return;const r=new Set;for(const s of t)if(s instanceof Ao)for(const l of Ns(n,s))r.add(l);else r.add(s);const a=As(e,r);for(const s of a)ws(e,o,s)}function As(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return l(t),a;function l(u){const f=new Set,_=Es(e,o,u,a,s);for(const y of _){var p;if(To(y).retainedBy==="recoilRoot"){s.add(y);continue}if(((p=n.retention.referenceCounts.get(y))!==null&&p!==void 0?p:0)>0){s.add(y);continue}if(No(y).some(X=>n.retention.referenceCounts.get(X))){s.add(y);continue}const E=r.nodeToNodeSubscriptions.get(y);if(E&&ys(E,X=>s.has(X))){s.add(y);continue}a.add(y),f.add(y)}const C=new Set;for(const y of f)for(const E of(V=r.nodeDeps.get(y))!==null&&V!==void 0?V:Eo){var V;a.has(E)||C.add(E)}C.size&&l(C)}}function Es(e,t,n,o,r){const a=e.getGraph(t.version),s=[],l=new Set;for(;n.size>0;)u(Z(n.values().next().value));return s;function u(f){if(o.has(f)||r.has(f)){n.delete(f);return}if(l.has(f))return;const _=a.nodeToNodeSubscriptions.get(f);if(_)for(const p of _)u(p);l.add(f),n.delete(f),s.push(f)}}function ws(e,t,n){if(!G("recoil_memory_managament_2020"))return;gs(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=No(n);for(const u of r){var a;(a=o.retention.nodesRetainedByZone.get(u))===null||a===void 0||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const u=s.nodeDeps.get(n);if(u!==void 0){s.nodeDeps.delete(n);for(const f of u){var l;(l=s.nodeToNodeSubscriptions.get(f))===null||l===void 0||l.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}bs(n)}function Ns(e,t){var n;return(n=e.retention.nodesRetainedByZone.get(t))!==null&&n!==void 0?n:Eo}function No(e){const t=To(e).retainedBy;return t===void 0||t==="components"||t==="recoilRoot"?[]:t instanceof Ao?[t]:t}function Ls(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):wo(e,new Set([t]))}function Vs(e,t,n){var o;if(!G("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=((o=r.get(t))!==null&&o!==void 0?o:0)+n;a===0?Lo(e,t):r.set(t,a)}function Lo(e,t){if(!G("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),Ls(e,t)}function Cs(e){if(!G("recoil_memory_managament_2020"))return;const t=e.getState();wo(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()}function $s(e){return e===void 0?"recoilRoot":e}var $e={SUSPENSE_TIMEOUT_MS:Ts,updateRetainCount:Vs,updateRetainCountToZero:Lo,releaseScheduledRetainablesNow:Cs,retainedByOptionWithDefault:$s};const{unstable_batchedUpdates:Ms}=Er;var Us={unstable_batchedUpdates:Ms};const{unstable_batchedUpdates:Is}=Us;var ks={unstable_batchedUpdates:Is};const{batchStart:Ds}=Se,{unstable_batchedUpdates:Bs}=ks;let pn=Bs||(e=>e());const Ps=e=>{pn=e},Os=()=>pn,xs=e=>{pn(()=>{let t=()=>{};try{t=Ds(),e()}finally{t()}})};var Vt={getBatcher:Os,setBatcher:Ps,batchUpdates:xs};function*Fs(e){for(const t of e)for(const n of t)yield n}var Vo=Fs;const Co=typeof Window>"u"||typeof window>"u",zs=e=>!Co&&(e===window||e instanceof Window),Ws=typeof navigator<"u"&&navigator.product==="ReactNative";var Ct={isSSR:Co,isReactNative:Ws,isWindow:zs};function Gs(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e(...o)),n[r]}}function Ks(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e(...r)),o}}function Hs(e,t){let n,o;return[(...s)=>{const l=t(...s);return n===l||(n=l,o=e(...s)),o},()=>{n=null}]}var js={memoizeWithArgsHash:Gs,memoizeOneWithArgsHash:Ks,memoizeOneWithArgsHashAndInvalidation:Hs};const{batchUpdates:en}=Vt,{initializeNode:qs,peekNodeInfo:Zs}=Te,{graph:Ys}=st,{getNextStoreID:Xs}=wt,{DEFAULT_VALUE:Js,recoilValues:$n,recoilValuesForKeys:Mn}=le,{AbstractRecoilValue:Qs,getRecoilValueAsLoadable:ei,setRecoilValue:Un,setUnvalidatedRecoilValue:ti}=Se,{updateRetainCount:pt}=$e,{setInvalidateMemoizedSnapshot:ni}=po,{getNextTreeStateVersion:oi,makeEmptyStoreState:ri}=co,{isSSR:ai}=Ct,{memoizeOneWithArgsHashAndInvalidation:si}=js;class $t{constructor(t,n){M(this,"_store",void 0),M(this,"_refCount",1),M(this,"getLoadable",o=>(this.checkRefCount_INTERNAL(),ei(this._store,o))),M(this,"getPromise",o=>(this.checkRefCount_INTERNAL(),this.getLoadable(o).toPromise())),M(this,"getNodes_UNSTABLE",o=>{if(this.checkRefCount_INTERNAL(),o?.isModified===!0){if(o?.isInitialized===!1)return[];const s=this._store.getState().currentTree;return Mn(s.dirtyAtoms)}const r=this._store.getState().knownAtoms,a=this._store.getState().knownSelectors;return o?.isInitialized==null?$n.values():o.isInitialized===!0?Mn(Vo([r,a])):hn($n.values(),({key:s})=>!r.has(s)&&!a.has(s))}),M(this,"getInfo_UNSTABLE",({key:o})=>(this.checkRefCount_INTERNAL(),Zs(this._store,this._store.getState().currentTree,o))),M(this,"map",o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return o(r),r}),M(this,"asyncMap",async o=>{this.checkRefCount_INTERNAL();const r=new tn(this,en);return r.retain(),await o(r),r.autoRelease_INTERNAL(),r}),this._store={storeID:Xs(),parentStoreID:n,getState:()=>t,replaceState:o=>{t.currentTree=o(t.currentTree)},getGraph:o=>{const r=t.graphsByVersion;if(r.has(o))return Z(r.get(o));const a=Ys();return r.set(o,a),a},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw U("Cannot subscribe to Snapshots")}};for(const o of this._store.getState().knownAtoms)qs(this._store,o,"get"),pt(this._store,o,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0,this._refCount++;let t=!1;return()=>{t||(t=!0,this._release())}}autoRelease_INTERNAL(){ai||window.setTimeout(()=>this._release(),10)}_release(){if(this._refCount--,this._refCount===0){if(this._store.getState().nodeCleanupFunctions.forEach(t=>t()),this._store.getState().nodeCleanupFunctions.clear(),!G("recoil_memory_managament_2020"))return}else this._refCount<0}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){G("recoil_memory_managament_2020")&&this._refCount<=0}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function $o(e,t,n=!1){const o=e.getState(),r=n?oi():t.version;return{currentTree:{version:n?r:t.version,stateID:n?r:t.stateID,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:new Map().set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Et(o.nodeCleanupFunctions.entries(),([a])=>[a,()=>{}]))}}function ii(e){const t=new $t(ri());return e!=null?t.map(e):t}const[In,Mo]=si((e,t)=>{var n;const o=e.getState(),r=t==="latest"?(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree:Z(o.previousTree);return new $t($o(e,r),e.storeID)},(e,t)=>{var n,o;return String(t)+String(e.storeID)+String((n=e.getState().nextTree)===null||n===void 0?void 0:n.version)+String(e.getState().currentTree.version)+String((o=e.getState().previousTree)===null||o===void 0?void 0:o.version)});ni(Mo);function ci(e,t="latest"){const n=In(e,t);return n.isRetained()?n:(Mo(),In(e,t))}class tn extends $t{constructor(t,n){super($o(t.getStore_INTERNAL(),t.getStore_INTERNAL().getState().currentTree,!0),t.getStoreID()),M(this,"_batch",void 0),M(this,"set",(o,r)=>{this.checkRefCount_INTERNAL();const a=this.getStore_INTERNAL();this._batch(()=>{pt(a,o.key,1),Un(this.getStore_INTERNAL(),o,r)})}),M(this,"reset",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();this._batch(()=>{pt(r,o.key,1),Un(this.getStore_INTERNAL(),o,Js)})}),M(this,"setUnvalidatedAtomValues_DEPRECATED",o=>{this.checkRefCount_INTERNAL();const r=this.getStore_INTERNAL();en(()=>{for(const[a,s]of o.entries())pt(r,a,1),ti(r,new Qs(a),s)})}),this._batch=n}}var Mt={Snapshot:$t,MutableSnapshot:tn,freshSnapshot:ii,cloneSnapshot:ci},li=Mt.Snapshot,ui=Mt.MutableSnapshot,di=Mt.freshSnapshot,fi=Mt.cloneSnapshot,Ut=Object.freeze({__proto__:null,Snapshot:li,MutableSnapshot:ui,freshSnapshot:di,cloneSnapshot:fi});function hi(...e){const t=new Set;for(const n of e)for(const o of n)t.add(o);return t}var _i=hi;const{useRef:vi}=Y;function pi(e){const t=vi(e);return t.current===e&&typeof e=="function"&&(t.current=e()),t}var kn=pi;const{getNextTreeStateVersion:Si,makeEmptyStoreState:Uo}=co,{cleanUpNode:Ri,getDownstreamNodes:mi,initializeNode:yi,setNodeValue:gi,setUnvalidatedAtomValue_DEPRECATED:bi}=Te,{graph:Ti}=st,{cloneGraph:Ai}=st,{getNextStoreID:Io}=wt,{createMutableSource:qt,reactMode:ko}=at,{applyAtomValueWrites:Ei}=Se,{releaseScheduledRetainablesNow:Do}=$e,{freshSnapshot:wi}=Ut,{useCallback:Ni,useContext:Bo,useEffect:nn,useMemo:Li,useRef:Vi,useState:Ci}=Y;function qe(){throw U("This component must be used inside a <RecoilRoot> component.")}const Po=Object.freeze({storeID:Io(),getState:qe,replaceState:qe,getGraph:qe,subscribeToTransactions:qe,addTransactionMetadata:qe});let on=!1;function Dn(e){if(on)throw U("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(t.nextTree===null){G("recoil_memory_managament_2020")&&G("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&Do(e);const n=t.currentTree.version,o=Si();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Ai(Z(t.graphsByVersion.get(n))))}}const Oo=Y.createContext({current:Po}),It=()=>Bo(Oo),xo=Y.createContext(null);function $i(){return Bo(xo)}function Sn(e,t,n){const o=mi(e,n,n.dirtyAtoms);for(const r of o){const a=t.nodeToComponentSubscriptions.get(r);if(a)for(const[s,[l,u]]of a)u(n)}}function Fo(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[r,a]of t.nodeTransactionSubscriptions)if(o.has(r))for(const[s,l]of a)l(e);for(const[r,a]of t.transactionSubscriptions)a(e);(!ko().early||t.suspendedComponentResolvers.size>0)&&(Sn(e,t,n),t.suspendedComponentResolvers.forEach(r=>r()),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach(r=>r(n)),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Mi(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(n==null)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Fo(e),t.previousTree!=null?t.graphsByVersion.delete(t.previousTree.version):cn("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,G("recoil_memory_managament_2020")&&n==null&&Do(e)}finally{t.commitDepth--}}function Ui({setNotifyBatcherOfChange:e}){const t=It(),[,n]=Ci([]);return e(()=>n({})),nn(()=>(e(()=>n({})),()=>{e(()=>{})}),[e]),nn(()=>{da.enqueueExecution("Batcher",()=>{Mi(t.current)})}),null}function Ii(e,t){const n=Uo();return t({set:(o,r)=>{const a=n.currentTree,s=gi(e,a,o.key,r),l=new Set(s.keys()),u=a.nonvalidatedAtoms.clone();for(const f of l)u.delete(f);n.currentTree={...a,dirtyAtoms:_i(a.dirtyAtoms,l),atomValues:Ei(a.atomValues,s),nonvalidatedAtoms:u}},setUnvalidatedAtomValues:o=>{o.forEach((r,a)=>{n.currentTree=bi(n.currentTree,a,r)})}}),n}function ki(e){const t=wi(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach(o=>o()),n.nodeCleanupFunctions.clear(),n}let Bn=0;function Di({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let r;const a=V=>{const y=r.current.graphsByVersion;if(y.has(V))return Z(y.get(V));const E=Ti();return y.set(V,E),E},s=(V,y)=>{if(y==null){const{transactionSubscriptions:E}=p.current.getState(),X=Bn++;return E.set(X,V),{release:()=>{E.delete(X)}}}else{const{nodeTransactionSubscriptions:E}=p.current.getState();E.has(y)||E.set(y,new Map);const X=Bn++;return Z(E.get(y)).set(X,V),{release:()=>{const ne=E.get(y);ne&&(ne.delete(X),ne.size===0&&E.delete(y))}}}},l=V=>{Dn(p.current);for(const y of Object.keys(V))Z(p.current.getState().nextTree).transactionMetadata[y]=V[y]},u=V=>{Dn(p.current);const y=Z(r.current.nextTree);let E;try{on=!0,E=V(y)}finally{on=!1}E!==y&&(r.current.nextTree=E,ko().early&&Sn(p.current,r.current,E),Z(f.current)())},f=Vi(null),_=Ni(V=>{f.current=V},[f]),p=kn(()=>n??{storeID:Io(),getState:()=>r.current,replaceState:u,getGraph:a,subscribeToTransactions:s,addTransactionMetadata:l});n!=null&&(p.current=n),r=kn(()=>e!=null?Ii(p.current,e):t!=null?ki(t):Uo());const C=Li(()=>qt?.(r,()=>r.current.currentTree.version),[r]);return nn(()=>{const V=p.current;for(const y of new Set(V.getState().knownAtoms))yi(V,y,"get");return()=>{for(const y of V.getState().knownAtoms)Ri(V,y)}},[p]),Y.createElement(Oo.Provider,{value:p},Y.createElement(xo.Provider,{value:C},Y.createElement(Ui,{setNotifyBatcherOfChange:_}),o))}function Bi(e){const{override:t,...n}=e,o=It();return t===!1&&o.current!==Po?e.children:Y.createElement(Di,n)}function Pi(){return It().current.storeID}var ge={RecoilRoot:Bi,useStoreRef:It,useRecoilMutableSource:$i,useRecoilStoreID:Pi,notifyComponents_FOR_TESTING:Sn,sendEndOfBatchNotifications_FOR_TESTING:Fo};function Oi(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0}var xi=Oi;const{useEffect:Fi,useRef:zi}=Y;function Wi(e){const t=zi();return Fi(()=>{t.current=e}),t.current}var zo=Wi;const{useStoreRef:Gi}=ge,{SUSPENSE_TIMEOUT_MS:Ki}=$e,{updateRetainCount:Ze}=$e,{RetentionZone:Hi}=Nt,{useEffect:ji,useRef:qi}=Y,{isSSR:Pn}=Ct;function Zi(e){if(G("recoil_memory_managament_2020"))return Yi(e)}function Yi(e){const n=(Array.isArray(e)?e:[e]).map(s=>s instanceof Hi?s:s.key),o=Gi();ji(()=>{if(!G("recoil_memory_managament_2020"))return;const s=o.current;if(r.current&&!Pn)window.clearTimeout(r.current),r.current=null;else for(const l of n)Ze(s,l,1);return()=>{for(const l of n)Ze(s,l,-1)}},[o,...n]);const r=qi(),a=zo(n);if(!Pn&&(a===void 0||!xi(a,n))){const s=o.current;for(const l of n)Ze(s,l,1);if(a)for(const l of a)Ze(s,l,-1);r.current&&window.clearTimeout(r.current),r.current=window.setTimeout(()=>{r.current=null;for(const l of n)Ze(s,l,-1)},Ki)}}var Rn=Zi;function Xi(){return"<component name not available>"}var ct=Xi;const{batchUpdates:Ji}=Vt,{DEFAULT_VALUE:Wo}=le,{currentRendererSupportsUseSyncExternalStore:Qi,reactMode:Ke,useMutableSource:ec,useSyncExternalStore:tc}=at,{useRecoilMutableSource:nc,useStoreRef:Re}=ge,{AbstractRecoilValue:rn,getRecoilValueAsLoadable:lt,setRecoilValue:mt,setUnvalidatedRecoilValue:oc,subscribeToRecoilValue:Fe}=Se,{useCallback:ce,useEffect:ze,useMemo:Go,useRef:nt,useState:mn}=Y,{setByAddingToSet:rc}=uo,{isSSR:ac}=Ct;function yn(e,t,n){if(e.state==="hasValue")return e.contents;throw e.state==="loading"?new Promise(r=>{const a=n.current.getState().suspendedComponentResolvers;a.add(r),ac&&K(e.contents)&&e.contents.finally(()=>{a.delete(r)})}):e.state==="hasError"?e.contents:U(`Invalid value of loadable atom "${t.key}"`)}function sc(){const e=ct(),t=Re(),[,n]=mn([]),o=nt(new Set);o.current=new Set;const r=nt(new Set),a=nt(new Map),s=ce(u=>{const f=a.current.get(u);f&&(f.release(),a.current.delete(u))},[a]),l=ce((u,f)=>{a.current.has(f)&&n([])},[]);return ze(()=>{const u=t.current;et(o.current,r.current).forEach(f=>{if(a.current.has(f))return;const _=Fe(u,new rn(f),C=>l(C,f),e);a.current.set(f,_),u.getState().nextTree?u.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{l(u.getState(),f)}):l(u.getState(),f)}),et(r.current,o.current).forEach(f=>{s(f)}),r.current=o.current}),ze(()=>{const u=a.current;return et(o.current,new Set(u.keys())).forEach(f=>{const _=Fe(t.current,new rn(f),p=>l(p,f),e);u.set(f,_)}),()=>u.forEach((f,_)=>s(_))},[e,t,s,l]),Go(()=>{function u(y){return E=>{mt(t.current,y,E)}}function f(y){return()=>mt(t.current,y,Wo)}function _(y){var E;o.current.has(y.key)||(o.current=rc(o.current,y.key));const X=t.current.getState();return lt(t.current,y,Ke().early&&(E=X.nextTree)!==null&&E!==void 0?E:X.currentTree)}function p(y){const E=_(y);return yn(E,y,t)}function C(y){return[p(y),u(y)]}function V(y){return[_(y),u(y)]}return{getRecoilValue:p,getRecoilValueLoadable:_,getRecoilState:C,getRecoilStateLoadable:V,getSetRecoilState:u,getResetRecoilState:f}},[o,t])}const ic={current:0};function cc(e){const t=Re(),n=ct(),o=ce(()=>{var l;const u=t.current,f=u.getState(),_=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return{loadable:lt(u,e,_),key:e.key}},[t,e]),r=ce(l=>{let u;return()=>{var f,_;const p=l();return(f=u)!==null&&f!==void 0&&f.loadable.is(p.loadable)&&((_=u)===null||_===void 0?void 0:_.key)===p.key?u:(u=p,p)}},[]),a=Go(()=>r(o),[o,r]),s=ce(l=>{const u=t.current;return Fe(u,e,l,n).release},[t,e,n]);return tc(s,a,a).loadable}function lc(e){const t=Re(),n=ce(()=>{var f;const _=t.current,p=_.getState(),C=Ke().early&&(f=p.nextTree)!==null&&f!==void 0?f:p.currentTree;return lt(_,e,C)},[t,e]),o=ce(()=>n(),[n]),r=ct(),a=ce((f,_)=>{const p=t.current;return Fe(p,e,()=>{if(!G("recoil_suppress_rerender_in_callback"))return _();const V=n();u.current.is(V)||_(),u.current=V},r).release},[t,e,r,n]),s=nc();if(s==null)throw U("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const l=ec(s,o,a),u=nt(l);return ze(()=>{u.current=l}),l}function an(e){const t=Re(),n=ct(),o=ce(()=>{var u;const f=t.current,_=f.getState(),p=Ke().early&&(u=_.nextTree)!==null&&u!==void 0?u:_.currentTree;return lt(f,e,p)},[t,e]),r=ce(()=>({loadable:o(),key:e.key}),[o,e.key]),a=ce(u=>{const f=r();return u.loadable.is(f.loadable)&&u.key===f.key?u:f},[r]);ze(()=>{const u=Fe(t.current,e,f=>{l(a)},n);return l(a),u.release},[n,e,t,a]);const[s,l]=mn(r);return s.key!==e.key?r().loadable:s.loadable}function uc(e){const t=Re(),[,n]=mn([]),o=ct(),r=ce(()=>{var l;const u=t.current,f=u.getState(),_=Ke().early&&(l=f.nextTree)!==null&&l!==void 0?l:f.currentTree;return lt(u,e,_)},[t,e]),a=r(),s=nt(a);return ze(()=>{s.current=a}),ze(()=>{const l=t.current,u=l.getState(),f=Fe(l,e,p=>{var C;if(!G("recoil_suppress_rerender_in_callback"))return n([]);const V=r();(C=s.current)!==null&&C!==void 0&&C.is(V)||n(V),s.current=V},o);if(u.nextTree)l.getState().queuedComponentCallbacks_DEPRECATED.push(()=>{s.current=null,n([])});else{var _;if(!G("recoil_suppress_rerender_in_callback"))return n([]);const p=r();(_=s.current)!==null&&_!==void 0&&_.is(p)||n(p),s.current=p}return f.release},[o,r,e,t]),a}function gn(e){return G("recoil_memory_managament_2020")&&Rn(e),{TRANSITION_SUPPORT:an,SYNC_EXTERNAL_STORE:Qi()?cc:an,MUTABLE_SOURCE:lc,LEGACY:uc}[Ke().mode](e)}function Ko(e){const t=Re(),n=gn(e);return yn(n,e,t)}function kt(e){const t=Re();return ce(n=>{mt(t.current,e,n)},[t,e])}function dc(e){const t=Re();return ce(()=>{mt(t.current,e,Wo)},[t,e])}function fc(e){return[Ko(e),kt(e)]}function hc(e){return[gn(e),kt(e)]}function _c(){const e=Re();return(t,n={})=>{Ji(()=>{e.current.addTransactionMetadata(n),t.forEach((o,r)=>oc(e.current,new rn(r),o))})}}function Ho(e){return G("recoil_memory_managament_2020")&&Rn(e),an(e)}function jo(e){const t=Re(),n=Ho(e);return yn(n,e,t)}function vc(e){return[jo(e),kt(e)]}var pc={recoilComponentGetRecoilValueCount_FOR_TESTING:ic,useRecoilInterface:sc,useRecoilState:fc,useRecoilStateLoadable:hc,useRecoilValue:Ko,useRecoilValueLoadable:gn,useResetRecoilState:dc,useSetRecoilState:kt,useSetUnvalidatedAtomValues:_c,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Ho,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:jo,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:vc};function Sc(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n}var Rc=Sc;function mc(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n}var yc=mc;function gc(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t}var bc=gc;const{batchUpdates:Tc}=Vt,{DEFAULT_VALUE:Ac,getNode:qo,nodes:Ec}=le,{useStoreRef:bn}=ge,{AbstractRecoilValue:wc,setRecoilValueLoadable:Nc}=Se,{SUSPENSE_TIMEOUT_MS:Lc}=$e,{cloneSnapshot:yt}=Ut,{useCallback:Dt,useEffect:Zo,useRef:On,useState:Vc}=Y,{isSSR:xn}=Ct;function Bt(e){const t=bn();Zo(()=>t.current.subscribeToTransactions(e).release,[e,t])}function Fn(e){const t=e.atomValues.toMap(),n=Rt(Rc(t,(o,r)=>{const s=qo(r).persistence_UNSTABLE;return s!=null&&s.type!=="none"&&o.state==="hasValue"}),o=>o.contents);return bc(e.nonvalidatedAtoms.toMap(),n)}function Cc(e){Bt(Dt(t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(n=t.getState().currentTree);const r=Fn(o),a=Fn(n),s=Rt(Ec,u=>{var f,_,p,C;return{persistence_UNSTABLE:{type:(f=(_=u.persistence_UNSTABLE)===null||_===void 0?void 0:_.type)!==null&&f!==void 0?f:"none",backButton:(p=(C=u.persistence_UNSTABLE)===null||C===void 0?void 0:C.backButton)!==null&&p!==void 0?p:!1}}}),l=yc(o.dirtyAtoms,u=>r.has(u)||a.has(u));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:l,transactionMetadata:{...o.transactionMetadata}})},[e]))}function $c(e){Bt(Dt(t=>{const n=yt(t,"latest"),o=yt(t,"previous");e({snapshot:n,previousSnapshot:o})},[e]))}function Mc(){const e=bn(),[t,n]=Vc(()=>yt(e.current)),o=zo(t),r=On(),a=On();if(Bt(Dt(l=>n(yt(l)),[])),Zo(()=>{const l=t.retain();if(r.current&&!xn){var u;window.clearTimeout(r.current),r.current=null,(u=a.current)===null||u===void 0||u.call(a),a.current=null}return()=>{window.setTimeout(l,10)}},[t]),o!==t&&!xn){if(r.current){var s;window.clearTimeout(r.current),r.current=null,(s=a.current)===null||s===void 0||s.call(a),a.current=null}a.current=t.retain(),r.current=window.setTimeout(()=>{var l;r.current=null,(l=a.current)===null||l===void 0||l.call(a),a.current=null},Lc)}return t}function Yo(e,t){var n;const o=e.getState(),r=(n=o.nextTree)!==null&&n!==void 0?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;Tc(()=>{const s=new Set;for(const f of[r.atomValues.keys(),a.atomValues.keys()])for(const _ of f){var l,u;((l=r.atomValues.get(_))===null||l===void 0?void 0:l.contents)!==((u=a.atomValues.get(_))===null||u===void 0?void 0:u.contents)&&qo(_).shouldRestoreFromSnapshots&&s.add(_)}s.forEach(f=>{Nc(e,new wc(f),a.atomValues.has(f)?Z(a.atomValues.get(f)):Ac)}),e.replaceState(f=>({...f,stateID:t.getID()}))})}function Uc(){const e=bn();return Dt(t=>Yo(e.current,t),[e])}var Xo={useRecoilSnapshot:Mc,gotoSnapshot:Yo,useGotoRecoilSnapshot:Uc,useRecoilTransactionObserver:$c,useTransactionObservation_DEPRECATED:Cc,useTransactionSubscription_DEPRECATED:Bt};const{peekNodeInfo:Ic}=Te,{useStoreRef:kc}=ge;function Dc(){const e=kc();return({key:t})=>Ic(e.current,e.current.getState().currentTree,t)}var Bc=Dc;const{reactMode:Pc}=at,{RecoilRoot:Oc,useStoreRef:xc}=ge,{useMemo:Fc}=Y;function zc(){Pc().mode==="MUTABLE_SOURCE"&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=xc().current;return Fc(()=>{function t({children:n}){return Y.createElement(Oc,{store_INTERNAL:e},n)}return t},[e])}var Wc=zc;const{loadableWithValue:Gc}=rt,{initializeNode:Kc}=Te,{DEFAULT_VALUE:Hc,getNode:jc}=le,{copyTreeState:qc,getRecoilValueAsLoadable:Zc,invalidateDownstreams:Yc,writeLoadableToTreeState:Xc}=Se;function zn(e){return jc(e.key).nodeType==="atom"}class Jc{constructor(t,n){M(this,"_store",void 0),M(this,"_treeState",void 0),M(this,"_changes",void 0),M(this,"get",o=>{if(this._changes.has(o.key))return this._changes.get(o.key);if(!zn(o))throw U("Reading selectors within atomicUpdate is not supported");const r=Zc(this._store,o,this._treeState);if(r.state==="hasValue")return r.contents;throw r.state==="hasError"?r.contents:U(`Expected Recoil atom ${o.key} to have a value, but it is in a loading state.`)}),M(this,"set",(o,r)=>{if(!zn(o))throw U("Setting selectors within atomicUpdate is not supported");if(typeof r=="function"){const a=this.get(o);this._changes.set(o.key,r(a))}else Kc(this._store,o.key,"set"),this._changes.set(o.key,r)}),M(this,"reset",o=>{this.set(o,Hc)}),this._store=t,this._treeState=n,this._changes=new Map}newTreeState_INTERNAL(){if(this._changes.size===0)return this._treeState;const t=qc(this._treeState);for(const[n,o]of this._changes)Xc(t,n,Gc(o));return Yc(this._store,t),t}}function Qc(e){return t=>{e.replaceState(n=>{const o=new Jc(e,n);return t(o),o.newTreeState_INTERNAL()})}}var el={atomicUpdater:Qc},tl=el.atomicUpdater,Jo=Object.freeze({__proto__:null,atomicUpdater:tl});function nl(e,t){if(!e)throw new Error(t)}var ol=nl,Qe=ol;const{atomicUpdater:rl}=Jo,{batchUpdates:al}=Vt,{DEFAULT_VALUE:sl}=le,{useStoreRef:il}=ge,{refreshRecoilValue:cl,setRecoilValue:Wn}=Se,{cloneSnapshot:ll}=Ut,{gotoSnapshot:ul}=Xo,{useCallback:dl}=Y;class Qo{}const fl=new Qo;function er(e,t,n,o){let r=fl,a;if(al(()=>{const l="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if(typeof t!="function")throw U(l);const u=fo({...o??{},set:(_,p)=>Wn(e,_,p),reset:_=>Wn(e,_,sl),refresh:_=>cl(e,_),gotoSnapshot:_=>ul(e,_),transact_UNSTABLE:_=>rl(e)(_)},{snapshot:()=>{const _=ll(e);return a=_.retain(),_}}),f=t(u);if(typeof f!="function")throw U(l);r=f(...n)}),r instanceof Qo&&Qe(!1),K(r))r=r.finally(()=>{var l;(l=a)===null||l===void 0||l()});else{var s;(s=a)===null||s===void 0||s()}return r}function hl(e,t){const n=il();return dl((...o)=>er(n.current,e,o),t!=null?[...t,n]:void 0)}var tr={recoilCallback:er,useRecoilCallback:hl};const{useStoreRef:_l}=ge,{refreshRecoilValue:vl}=Se,{useCallback:pl}=Y;function Sl(e){const t=_l();return pl(()=>{const n=t.current;vl(n,e)},[e,t])}var Rl=Sl;const{atomicUpdater:ml}=Jo,{useStoreRef:yl}=ge,{useMemo:gl}=Y;function bl(e,t){const n=yl();return gl(()=>(...o)=>{ml(n.current)(a=>{e(a)(...o)})},t!=null?[...t,n]:void 0)}var Tl=bl;class Al{constructor(t){M(this,"value",void 0),this.value=t}}var El={WrappedValue:Al},wl=El.WrappedValue,nr=Object.freeze({__proto__:null,WrappedValue:wl});const{isFastRefreshEnabled:Nl}=at;class Gn extends Error{}class Ll{constructor(t){var n,o,r;M(this,"_name",void 0),M(this,"_numLeafs",void 0),M(this,"_root",void 0),M(this,"_onHit",void 0),M(this,"_onSet",void 0),M(this,"_mapNodeValue",void 0),this._name=t?.name,this._numLeafs=0,this._root=null,this._onHit=(n=t?.onHit)!==null&&n!==void 0?n:()=>{},this._onSet=(o=t?.onSet)!==null&&o!==void 0?o:()=>{},this._mapNodeValue=(r=t?.mapNodeValue)!==null&&r!==void 0?r:a=>a}size(){return this._numLeafs}root(){return this._root}get(t,n){var o;return(o=this.getLeafNode(t,n))===null||o===void 0?void 0:o.value}getLeafNode(t,n){if(this._root==null)return;let o=this._root;for(;o;){if(n?.onNodeVisit(o),o.type==="leaf")return this._onHit(o),o;const r=this._mapNodeValue(t(o.nodeKey));o=o.branches.get(r)}}set(t,n,o){const r=()=>{var a,s,l,u;let f,_;for(const[X,ne]of t){var p,C,V;const A=this._root;if(A?.type==="leaf")throw this.invalidCacheError();const P=f;if(f=P?P.branches.get(_):A,f=(p=f)!==null&&p!==void 0?p:{type:"branch",nodeKey:X,parent:P,branches:new Map,branchKey:_},f.type!=="branch"||f.nodeKey!==X)throw this.invalidCacheError();P?.branches.set(_,f),o==null||(C=o.onNodeVisit)===null||C===void 0||C.call(o,f),_=this._mapNodeValue(ne),this._root=(V=this._root)!==null&&V!==void 0?V:f}const y=f?(a=f)===null||a===void 0?void 0:a.branches.get(_):this._root;if(y!=null&&(y.type!=="leaf"||y.branchKey!==_))throw this.invalidCacheError();const E={type:"leaf",value:n,parent:f,branchKey:_};(s=f)===null||s===void 0||s.branches.set(_,E),this._root=(l=this._root)!==null&&l!==void 0?l:E,this._numLeafs++,this._onSet(E),o==null||(u=o.onNodeVisit)===null||u===void 0||u.call(o,E)};try{r()}catch(a){if(a instanceof Gn)this.clear(),r();else throw a}}delete(t){const n=this.root();if(!n)return!1;if(t===n)return this._root=null,this._numLeafs=0,!0;let o=t.parent,r=t.branchKey;for(;o;){var a;if(o.branches.delete(r),o===n)return o.branches.size===0?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(o.branches.size>0)break;r=(a=o)===null||a===void 0?void 0:a.branchKey,o=o.parent}for(;o!==n;o=o.parent)if(o==null)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const t=Nl()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw cn(t+(this._name!=null?` - ${this._name}`:"")),new Gn}}var Vl={TreeCache:Ll},Cl=Vl.TreeCache,or=Object.freeze({__proto__:null,TreeCache:Cl});class $l{constructor(t){var n;M(this,"_maxSize",void 0),M(this,"_size",void 0),M(this,"_head",void 0),M(this,"_tail",void 0),M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._maxSize=t.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=(n=t.mapKey)!==null&&n!==void 0?n:o=>o}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(t){return this._map.has(this._keyMapper(t))}get(t){const n=this._keyMapper(t),o=this._map.get(n);if(o)return this.set(t,o.value),o.value}set(t,n){const o=this._keyMapper(t);this._map.get(o)&&this.delete(t);const a=this.head(),s={key:t,right:a,left:null,value:n};a?a.left=s:this._tail=s,this._map.set(o,s),this._head=s,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const t=this.tail();t&&this.delete(t.key)}delete(t){const n=this._keyMapper(t);if(!this._size||!this._map.has(n))return;const o=Z(this._map.get(n)),r=o.right,a=o.left;r&&(r.left=o.left),a&&(a.right=o.right),o===this.head()&&(this._head=r),o===this.tail()&&(this._tail=a),this._map.delete(n),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}}var Ml={LRUCache:$l},Ul=Ml.LRUCache,rr=Object.freeze({__proto__:null,LRUCache:Ul});const{LRUCache:Il}=rr,{TreeCache:kl}=or;function Dl({name:e,maxSize:t,mapNodeValue:n=o=>o}){const o=new Il({maxSize:t}),r=new kl({name:e,mapNodeValue:n,onHit:a=>{o.set(a,!0)},onSet:a=>{const s=o.tail();o.set(a,!0),s&&r.size()>t&&r.delete(s.key)}});return r}var Kn=Dl;function pe(e,t,n){if(typeof e=="string"&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(t?.allowFunctions!==!0)throw U("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(e===null)return"null";if(typeof e!="object"){var o;return(o=JSON.stringify(e))!==null&&o!==void 0?o:""}if(K(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map((r,a)=>pe(r,t,a.toString()))}]`;if(typeof e.toJSON=="function")return pe(e.toJSON(n),t,n);if(e instanceof Map){const r={};for(const[a,s]of e)r[typeof a=="string"?a:pe(a,t)]=s;return pe(r,t,n)}return e instanceof Set?pe(Array.from(e).sort((r,a)=>pe(r,t).localeCompare(pe(a,t))),t,n):Symbol!==void 0&&e[Symbol.iterator]!=null&&typeof e[Symbol.iterator]=="function"?pe(Array.from(e),t,n):`{${Object.keys(e).filter(r=>e[r]!==void 0).sort().map(r=>`${pe(r,t)}:${pe(e[r],t,r)}`).join(",")}}`}function Bl(e,t={allowFunctions:!1}){return pe(e,t)}var Pt=Bl;const{TreeCache:Pl}=or,dt={equality:"reference",eviction:"keep-all",maxSize:1/0};function Ol({equality:e=dt.equality,eviction:t=dt.eviction,maxSize:n=dt.maxSize}=dt,o){const r=xl(e);return Fl(t,n,r,o)}function xl(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw U(`Unrecognized equality policy ${e}`)}function Fl(e,t,n,o){switch(e){case"keep-all":return new Pl({name:o,mapNodeValue:n});case"lru":return Kn({name:o,maxSize:Z(t),mapNodeValue:n});case"most-recent":return Kn({name:o,maxSize:1,mapNodeValue:n})}throw U(`Unrecognized eviction policy ${e}`)}var zl=Ol;function Wl(e){return()=>null}var Gl={startPerfBlock:Wl};const{isLoadable:Kl,loadableWithError:ft,loadableWithPromise:Hl,loadableWithValue:Zt}=rt,{WrappedValue:ar}=nr,{getNodeLoadable:ht,peekNodeLoadable:jl,setNodeValue:ql}=Te,{saveDepsToStore:Zl}=st,{DEFAULT_VALUE:Yl,getConfigDeletionHandler:Xl,getNode:Jl,registerNode:Hn}=le,{isRecoilValue:Ql}=xe,{markRecoilValueModified:jn}=Se,{retainedByOptionWithDefault:eu}=$e,{recoilCallback:tu}=tr,{startPerfBlock:nu}=Gl;class sr{}const Ye=new sr,Xe=[],_t=new Map,ou=(()=>{let e=0;return()=>e++})();function ir(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=e.set!=null?e.set:void 0,s=new Set,l=zl(r??{equality:"reference",eviction:"keep-all"},n),u=eu(e.retainedBy_UNSTABLE),f=new Map;let _=0;function p(){return!G("recoil_memory_managament_2020")||_>0}function C(d){return d.getState().knownSelectors.add(n),_++,()=>{_--}}function V(){return Xl(n)!==void 0&&!p()}function y(d,v,S,$,b){Ue(v,$,b),E(d,S)}function E(d,v){ue(d,v)&&re(d),ne(v,!0)}function X(d,v){ue(d,v)&&(Z(F(d)).stateVersions.clear(),ne(v,!1))}function ne(d,v){const S=_t.get(d);if(S!=null){for(const $ of S)jn($,Z(t));v&&_t.delete(d)}}function A(d,v){let S=_t.get(v);S==null&&_t.set(v,S=new Set),S.add(d)}function P(d,v,S,$,b,B){return v.then(D=>{if(!p())throw re(d),Ye;const T=Zt(D);return y(d,S,b,T,$),D}).catch(D=>{if(!p())throw re(d),Ye;if(K(D))return ee(d,D,S,$,b,B);const T=ft(D);throw y(d,S,b,T,$),D})}function ee(d,v,S,$,b,B){return v.then(D=>{if(!p())throw re(d),Ye;B.loadingDepKey!=null&&B.loadingDepPromise===v?S.atomValues.set(B.loadingDepKey,Zt(D)):d.getState().knownSelectors.forEach(z=>{S.atomValues.delete(z)});const T=J(d,S);if(T&&T.state!=="loading"){if((ue(d,b)||F(d)==null)&&E(d,b),T.state==="hasValue")return T.contents;throw T.contents}if(!ue(d,b)){const z=me(d,S);if(z!=null)return z.loadingLoadable.contents}const[j,te]=H(d,S,b);if(j.state!=="loading"&&y(d,S,b,j,te),j.state==="hasError")throw j.contents;return j.contents}).catch(D=>{if(D instanceof sr)throw Ye;if(!p())throw re(d),Ye;const T=ft(D);throw y(d,S,b,T,$),D})}function W(d,v,S,$){var b,B,D,T;if(ue(d,$)||v.version===((b=d.getState())===null||b===void 0||(B=b.currentTree)===null||B===void 0?void 0:B.version)||v.version===((D=d.getState())===null||D===void 0||(T=D.nextTree)===null||T===void 0?void 0:T.version)){var j,te,z;Zl(n,S,d,(j=(te=d.getState())===null||te===void 0||(z=te.nextTree)===null||z===void 0?void 0:z.version)!==null&&j!==void 0?j:d.getState().currentTree.version)}for(const Q of S)s.add(Q)}function H(d,v,S){const $=nu(n);let b=!0,B=!0;const D=()=>{$(),B=!1};let T,j=!1,te;const z={loadingDepKey:null,loadingDepPromise:null},Q=new Map;function _e({key:fe}){const de=ht(d,v,fe);switch(Q.set(fe,de),b||(W(d,v,new Set(Q.keys()),S),X(d,S)),de.state){case"hasValue":return de.contents;case"hasError":throw de.contents;case"loading":throw z.loadingDepKey=fe,z.loadingDepPromise=de.contents,de.contents}throw U("Invalid Loadable state")}const we=fe=>(...de)=>{if(B)throw U("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return t==null&&Qe(!1),tu(d,fe,de,{node:t})};try{T=o({get:_e,getCallback:we}),T=Ql(T)?_e(T):T,Kl(T)&&(T.state==="hasError"&&(j=!0),T=T.contents),K(T)?T=P(d,T,v,Q,S,z).finally(D):D(),T=T instanceof ar?T.value:T}catch(fe){T=fe,K(T)?T=ee(d,T,v,Q,S,z).finally(D):(j=!0,D())}return j?te=ft(T):K(T)?te=Hl(T):te=Zt(T),b=!1,Ee(d,S,Q),W(d,v,new Set(Q.keys()),S),[te,Q]}function J(d,v){let S=v.atomValues.get(n);if(S!=null)return S;const $=new Set;try{S=l.get(B=>(typeof B!="string"&&Qe(!1),ht(d,v,B).contents),{onNodeVisit:B=>{B.type==="branch"&&B.nodeKey!==n&&$.add(B.nodeKey)}})}catch(B){throw U(`Problem with cache lookup for selector "${n}": ${B.message}`)}if(S){var b;v.atomValues.set(n,S),W(d,v,$,(b=F(d))===null||b===void 0?void 0:b.executionID)}return S}function se(d,v){const S=J(d,v);if(S!=null)return re(d),S;const $=me(d,v);if($!=null){var b;return((b=$.loadingLoadable)===null||b===void 0?void 0:b.state)==="loading"&&A(d,$.executionID),$.loadingLoadable}const B=ou(),[D,T]=H(d,v,B);return D.state==="loading"?(ae(d,B,D,T,v),A(d,B)):(re(d),Ue(v,D,T)),D}function me(d,v){const S=Vo([f.has(d)?[Z(f.get(d))]:[],Et(hn(f,([b])=>b!==d),([,b])=>b)]);function $(b){for(const[B,D]of b)if(!ht(d,v,B).is(D))return!0;return!1}for(const b of S){if(b.stateVersions.get(v.version)||!$(b.depValuesDiscoveredSoFarDuringAsyncWork))return b.stateVersions.set(v.version,!0),b;b.stateVersions.set(v.version,!1)}}function F(d){return f.get(d)}function ae(d,v,S,$,b){f.set(d,{depValuesDiscoveredSoFarDuringAsyncWork:$,executionID:v,loadingLoadable:S,stateVersions:new Map([[b.version,!0]])})}function Ee(d,v,S){if(ue(d,v)){const $=F(d);$!=null&&($.depValuesDiscoveredSoFarDuringAsyncWork=S)}}function re(d){f.delete(d)}function ue(d,v){var S;return v===((S=F(d))===null||S===void 0?void 0:S.executionID)}function Me(d){return Array.from(d.entries()).map(([v,S])=>[v,S.contents])}function Ue(d,v,S){d.atomValues.set(n,v);try{l.set(Me(S),v)}catch($){throw U(`Problem with setting cache for selector "${n}": ${$.message}`)}}function ye(d){if(Xe.includes(n)){const v=`Recoil selector has circular dependencies: ${Xe.slice(Xe.indexOf(n)).join("  ")}`;return ft(U(v))}Xe.push(n);try{return d()}finally{Xe.pop()}}function Ie(d,v){const S=v.atomValues.get(n);return S??l.get($=>{var b;return typeof $!="string"&&Qe(!1),(b=jl(d,v,$))===null||b===void 0?void 0:b.contents})}function ke(d,v){return ye(()=>se(d,v))}function O(d){d.atomValues.delete(n)}function x(d,v){t==null&&Qe(!1);for(const $ of s){var S;const b=Jl($);(S=b.clearCache)===null||S===void 0||S.call(b,d,v)}s.clear(),O(v),l.clear(),jn(d,t)}return a!=null?t=Hn({key:n,nodeType:"selector",peek:Ie,get:ke,set:(v,S,$)=>{let b=!1;const B=new Map;function D({key:z}){if(b)throw U("Recoil: Async selector sets are not currently supported.");const Q=ht(v,S,z);if(Q.state==="hasValue")return Q.contents;if(Q.state==="loading"){const _e=`Getting value of asynchronous atom or selector "${z}" in a pending state while setting selector "${n}" is not yet supported.`;throw U(_e)}else throw Q.contents}function T(z,Q){if(b)throw U("Recoil: Async selector sets are not currently supported.");const _e=typeof Q=="function"?Q(D(z)):Q;ql(v,S,z.key,_e).forEach((fe,de)=>B.set(de,fe))}function j(z){T(z,Yl)}const te=a({set:T,get:D,reset:j},$);if(te!==void 0)throw K(te)?U("Recoil: Async selector sets are not currently supported."):U("Recoil: selector set should be a void function.");return b=!0,B},init:C,invalidate:O,clearCache:x,shouldDeleteConfigOnRelease:V,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u}):t=Hn({key:n,nodeType:"selector",peek:Ie,get:ke,init:C,invalidate:O,clearCache:x,shouldDeleteConfigOnRelease:V,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:u})}ir.value=e=>new ar(e);var We=ir;const{isLoadable:ru,loadableWithError:Yt,loadableWithPromise:Xt,loadableWithValue:Be}=rt,{WrappedValue:cr}=nr,{peekNodeInfo:au}=Te,{DEFAULT_VALUE:Ne,DefaultValue:be,getConfigDeletionHandler:lr,registerNode:su,setConfigDeletionHandler:iu}=le,{isRecoilValue:cu}=xe,{getRecoilValueAsLoadable:lu,markRecoilValueModified:uu,setRecoilValue:qn,setRecoilValueLoadable:du}=Se,{retainedByOptionWithDefault:fu}=$e,Je=e=>e instanceof cr?e.value:e;function hu(e){const{key:t,persistence_UNSTABLE:n}=e,o=fu(e.retainedBy_UNSTABLE);let r=0;function a(A){return Xt(A.then(P=>(s=Be(P),P)).catch(P=>{throw s=Yt(P),P}))}let s=K(e.default)?a(e.default):ru(e.default)?e.default.state==="loading"?a(e.default.contents):e.default:Be(Je(e.default));s.contents;let l;const u=new Map;function f(A){return A}function _(A,P){const ee=P.then(W=>{var H,J;return((J=((H=A.getState().nextTree)!==null&&H!==void 0?H:A.getState().currentTree).atomValues.get(t))===null||J===void 0?void 0:J.contents)===ee&&qn(A,ne,W),W}).catch(W=>{var H,J;throw((J=((H=A.getState().nextTree)!==null&&H!==void 0?H:A.getState().currentTree).atomValues.get(t))===null||J===void 0?void 0:J.contents)===ee&&du(A,ne,Yt(W)),W});return ee}function p(A,P,ee){var W;r++;const H=()=>{var F;r--,(F=u.get(A))===null||F===void 0||F.forEach(ae=>ae()),u.delete(A)};if(A.getState().knownAtoms.add(t),s.state==="loading"){const F=()=>{var ae;((ae=A.getState().nextTree)!==null&&ae!==void 0?ae:A.getState().currentTree).atomValues.has(t)||uu(A,ne)};s.contents.finally(F)}const J=(W=e.effects)!==null&&W!==void 0?W:e.effects_UNSTABLE;if(J!=null){let ue=function(O){if(ae&&O.key===t){const x=F;return x instanceof be?C(A,P):K(x)?Xt(x.then(d=>d instanceof be?s.toPromise():d)):Be(x)}return lu(A,O)},Me=function(O){return ue(O).toPromise()},Ue=function(O){var x;const d=au(A,(x=A.getState().nextTree)!==null&&x!==void 0?x:A.getState().currentTree,O.key);return ae&&O.key===t&&!(F instanceof be)?{...d,isSet:!0,loadable:ue(O)}:d},F=Ne,ae=!0,Ee=!1,re=null;const ye=O=>x=>{if(ae){const d=ue(ne),v=d.state==="hasValue"?d.contents:Ne;F=typeof x=="function"?x(v):x,K(F)&&(F=F.then(S=>(re={effect:O,value:S},S)))}else{if(K(x))throw U("Setting atoms to async values is not implemented.");typeof x!="function"&&(re={effect:O,value:Je(x)}),qn(A,ne,typeof x=="function"?d=>{const v=Je(x(d));return re={effect:O,value:v},v}:Je(x))}},Ie=O=>()=>ye(O)(Ne),ke=O=>x=>{var d;const{release:v}=A.subscribeToTransactions(S=>{var $;let{currentTree:b,previousTree:B}=S.getState();B||(B=b);const D=($=b.atomValues.get(t))!==null&&$!==void 0?$:s;if(D.state==="hasValue"){var T,j,te,z;const Q=D.contents,_e=(T=B.atomValues.get(t))!==null&&T!==void 0?T:s,we=_e.state==="hasValue"?_e.contents:Ne;((j=re)===null||j===void 0?void 0:j.effect)!==O||((te=re)===null||te===void 0?void 0:te.value)!==Q?x(Q,we,!b.atomValues.has(t)):((z=re)===null||z===void 0?void 0:z.effect)===O&&(re=null)}},t);u.set(A,[...(d=u.get(A))!==null&&d!==void 0?d:[],v])};for(const O of J)try{const x=O({node:ne,storeID:A.storeID,parentStoreID_UNSTABLE:A.parentStoreID,trigger:ee,setSelf:ye(O),resetSelf:Ie(O),onSet:ke(O),getPromise:Me,getLoadable:ue,getInfo_UNSTABLE:Ue});if(x!=null){var se;u.set(A,[...(se=u.get(A))!==null&&se!==void 0?se:[],x])}}catch(x){F=x,Ee=!0}if(ae=!1,!(F instanceof be)){var me;const O=Ee?Yt(F):K(F)?Xt(_(A,F)):Be(Je(F));O.contents,P.atomValues.set(t,O),(me=A.getState().nextTree)===null||me===void 0||me.atomValues.set(t,O)}}return H}function C(A,P){var ee,W;return(ee=(W=P.atomValues.get(t))!==null&&W!==void 0?W:l)!==null&&ee!==void 0?ee:s}function V(A,P){if(P.atomValues.has(t))return Z(P.atomValues.get(t));if(P.nonvalidatedAtoms.has(t)){if(l!=null)return l;if(n==null)return s;const ee=P.nonvalidatedAtoms.get(t),W=n.validator(ee,Ne);return l=W instanceof be?s:Be(W),l}else return s}function y(){l=void 0}function E(A,P,ee){if(P.atomValues.has(t)){const W=Z(P.atomValues.get(t));if(W.state==="hasValue"&&ee===W.contents)return new Map}else if(!P.nonvalidatedAtoms.has(t)&&ee instanceof be)return new Map;return l=void 0,new Map().set(t,Be(ee))}function X(){return lr(t)!==void 0&&r<=0}const ne=su({key:t,nodeType:"atom",peek:C,get:V,set:E,init:p,invalidate:y,shouldDeleteConfigOnRelease:X,dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return ne}function Tn(e){const{...t}=e,n="default"in e?e.default:new Promise(()=>{});return cu(n)?_u({...t,default:n}):hu({...t,default:n})}function _u(e){const t=Tn({...e,default:Ne,persistence_UNSTABLE:e.persistence_UNSTABLE===void 0?void 0:{...e.persistence_UNSTABLE,validator:o=>o instanceof be?o:Z(e.persistence_UNSTABLE).validator(o,Ne)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=We({key:`${e.key}__withFallback`,get:({get:o})=>{const r=o(t);return r instanceof be?e.default:r},set:({set:o},r)=>o(t,r),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:e.dangerouslyAllowMutability});return iu(n.key,lr(e.key)),n}Tn.value=e=>new cr(e);var ur=Tn;class vu{constructor(t){var n;M(this,"_map",void 0),M(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=(n=t?.mapKey)!==null&&n!==void 0?n:o=>o}size(){return this._map.size}has(t){return this._map.has(this._keyMapper(t))}get(t){return this._map.get(this._keyMapper(t))}set(t,n){this._map.set(this._keyMapper(t),n)}delete(t){this._map.delete(this._keyMapper(t))}clear(){this._map.clear()}}var pu={MapCache:vu},Su=pu.MapCache,Ru=Object.freeze({__proto__:null,MapCache:Su});const{LRUCache:Zn}=rr,{MapCache:mu}=Ru,vt={equality:"reference",eviction:"none",maxSize:1/0};function yu({equality:e=vt.equality,eviction:t=vt.eviction,maxSize:n=vt.maxSize}=vt){const o=gu(e);return bu(t,n,o)}function gu(e){switch(e){case"reference":return t=>t;case"value":return t=>Pt(t)}throw U(`Unrecognized equality policy ${e}`)}function bu(e,t,n){switch(e){case"keep-all":return new mu({mapKey:n});case"lru":return new Zn({mapKey:n,maxSize:Z(t)});case"most-recent":return new Zn({mapKey:n,maxSize:1})}throw U(`Unrecognized eviction policy ${e}`)}var dr=yu;const{setConfigDeletionHandler:Tu}=le;function Au(e){var t,n;const o=dr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a,s;const l=o.get(r);if(l!=null)return l;const{cachePolicyForParams_UNSTABLE:u,...f}=e,_="default"in e?e.default:new Promise(()=>{}),p=ur({...f,key:`${e.key}__${(a=Pt(r))!==null&&a!==void 0?a:"void"}`,default:typeof _=="function"?_(r):_,retainedBy_UNSTABLE:typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE,effects:typeof e.effects=="function"?e.effects(r):typeof e.effects_UNSTABLE=="function"?e.effects_UNSTABLE(r):(s=e.effects)!==null&&s!==void 0?s:e.effects_UNSTABLE});return o.set(r,p),Tu(p.key,()=>{o.delete(r)}),p}}var Eu=Au;const{setConfigDeletionHandler:wu}=le;let Nu=0;function Lu(e){var t,n;const o=dr({equality:(t=(n=e.cachePolicyForParams_UNSTABLE)===null||n===void 0?void 0:n.equality)!==null&&t!==void 0?t:"value",eviction:"keep-all"});return r=>{var a;let s;try{s=o.get(r)}catch(C){throw U(`Problem with cache lookup for selector ${e.key}: ${C.message}`)}if(s!=null)return s;const l=`${e.key}__selectorFamily/${(a=Pt(r,{allowFunctions:!0}))!==null&&a!==void 0?a:"void"}/${Nu++}`,u=C=>e.get(r)(C),f=e.cachePolicy_UNSTABLE,_=typeof e.retainedBy_UNSTABLE=="function"?e.retainedBy_UNSTABLE(r):e.retainedBy_UNSTABLE;let p;if(e.set!=null){const C=e.set;p=We({key:l,get:u,set:(y,E)=>C(r)(y,E),cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:_})}else p=We({key:l,get:u,cachePolicy_UNSTABLE:f,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:_});return o.set(r,p),wu(p.key,()=>{o.delete(r)}),p}}var Ae=Lu;const Vu=Ae({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Cu(e){return Vu(e)}var $u=Cu;const Mu=Ae({key:"__error",get:e=>()=>{throw U(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});function Uu(e){return Mu(e)}var Iu=Uu;function ku(e){return e}var Du=ku;const{loadableWithError:fr,loadableWithPromise:hr,loadableWithValue:_r}=rt;function Ot(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[r,a]of t.entries())try{n[r]=e(a)}catch(s){o[r]=s}return[n,o]}function Bu(e){return e!=null&&!K(e)}function xt(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map(t=>e[t])}function sn(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce((n,o,r)=>({...n,[o]:t[r]}),{})}function Pe(e,t,n){const o=n.map((r,a)=>r==null?_r(t[a]):K(r)?hr(r):fr(r));return sn(e,o)}function Pu(e,t){return t.map((n,o)=>n===void 0?e[o]:n)}const Ou=Ae({key:"__waitForNone",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return Pe(e,o,r)},dangerouslyAllowMutability:!0}),xu=Ae({key:"__waitForAny",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return r.some(a=>!K(a))?Pe(e,o,r):new Promise(a=>{for(const[s,l]of r.entries())K(l)&&l.then(u=>{o[s]=u,r[s]=void 0,a(Pe(e,o,r))}).catch(u=>{r[s]=u,a(Pe(e,o,r))})})},dangerouslyAllowMutability:!0}),Fu=Ae({key:"__waitForAll",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);if(r.every(s=>s==null))return sn(e,o);const a=r.find(Bu);if(a!=null)throw a;return Promise.all(r).then(s=>sn(e,Pu(o,s)))},dangerouslyAllowMutability:!0}),zu=Ae({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=xt(e),[o,r]=Ot(t,n);return r.every(a=>!K(a))?Pe(e,o,r):Promise.all(r.map((a,s)=>K(a)?a.then(l=>{o[s]=l,r[s]=void 0}).catch(l=>{o[s]=void 0,r[s]=l}):null)).then(()=>Pe(e,o,r))},dangerouslyAllowMutability:!0}),Wu=Ae({key:"__noWait",get:e=>({get:t})=>{try{return We.value(_r(t(e)))}catch(n){return We.value(K(n)?hr(n):fr(n))}},dangerouslyAllowMutability:!0});var Gu={waitForNone:Ou,waitForAny:xu,waitForAll:Fu,waitForAllSettled:zu,noWait:Wu};const{RecoilLoadable:Ku}=rt,{DefaultValue:Hu}=le,{RecoilRoot:ju,useRecoilStoreID:qu}=ge,{isRecoilValue:Zu}=xe,{retentionZone:Yu}=Nt,{freshSnapshot:Xu}=Ut,{useRecoilState:Ju,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Qu,useRecoilStateLoadable:ed,useRecoilValue:td,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nd,useRecoilValueLoadable:od,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:rd,useResetRecoilState:ad,useSetRecoilState:sd}=pc,{useGotoRecoilSnapshot:id,useRecoilSnapshot:cd,useRecoilTransactionObserver:ld}=Xo,{useRecoilCallback:ud}=tr,{noWait:dd,waitForAll:fd,waitForAllSettled:hd,waitForAny:_d,waitForNone:vd}=Gu;var I={DefaultValue:Hu,isRecoilValue:Zu,RecoilLoadable:Ku,RecoilEnv:Ge,RecoilRoot:ju,useRecoilStoreID:qu,useRecoilBridgeAcrossReactRoots_UNSTABLE:Wc,atom:ur,selector:We,atomFamily:Eu,selectorFamily:Ae,constSelector:$u,errorSelector:Iu,readOnlySelector:Du,noWait:dd,waitForNone:vd,waitForAny:_d,waitForAll:fd,waitForAllSettled:hd,useRecoilValue:td,useRecoilValueLoadable:od,useRecoilState:Ju,useRecoilStateLoadable:ed,useSetRecoilState:sd,useResetRecoilState:ad,useGetRecoilValueInfo_UNSTABLE:Bc,useRecoilRefresher_UNSTABLE:Rl,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:rd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:nd,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Qu,useRecoilCallback:ud,useRecoilTransaction_UNSTABLE:Tl,useGotoRecoilSnapshot:id,useRecoilSnapshot:cd,useRecoilTransactionObserver_UNSTABLE:ld,snapshot_UNSTABLE:Xu,useRetain:Rn,retentionZone:Yu},pd=I.DefaultValue,Sd=I.isRecoilValue,Rd=I.RecoilLoadable,md=I.RecoilEnv,yd=I.RecoilRoot,gd=I.useRecoilStoreID,bd=I.useRecoilBridgeAcrossReactRoots_UNSTABLE,Td=I.atom,Ad=I.selector,Ed=I.atomFamily,wd=I.selectorFamily,Nd=I.constSelector,Ld=I.errorSelector,Vd=I.readOnlySelector,Cd=I.noWait,$d=I.waitForNone,Md=I.waitForAny,Ud=I.waitForAll,Id=I.waitForAllSettled,kd=I.useRecoilValue,Dd=I.useRecoilValueLoadable,Bd=I.useRecoilState,Pd=I.useRecoilStateLoadable,Od=I.useSetRecoilState,xd=I.useResetRecoilState,Fd=I.useGetRecoilValueInfo_UNSTABLE,zd=I.useRecoilRefresher_UNSTABLE,Wd=I.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,Gd=I.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,Kd=I.useRecoilState_TRANSITION_SUPPORT_UNSTABLE,Hd=I.useRecoilCallback,jd=I.useRecoilTransaction_UNSTABLE,qd=I.useGotoRecoilSnapshot,Zd=I.useRecoilSnapshot,Yd=I.useRecoilTransactionObserver_UNSTABLE,Xd=I.snapshot_UNSTABLE,Jd=I.useRetain,Qd=I.retentionZone;const nf=Object.freeze(Object.defineProperty({__proto__:null,DefaultValue:pd,RecoilEnv:md,RecoilLoadable:Rd,RecoilRoot:yd,atom:Td,atomFamily:Ed,constSelector:Nd,default:I,errorSelector:Ld,isRecoilValue:Sd,noWait:Cd,readOnlySelector:Vd,retentionZone:Qd,selector:Ad,selectorFamily:wd,snapshot_UNSTABLE:Xd,useGetRecoilValueInfo_UNSTABLE:Fd,useGotoRecoilSnapshot:qd,useRecoilBridgeAcrossReactRoots_UNSTABLE:bd,useRecoilCallback:Hd,useRecoilRefresher_UNSTABLE:zd,useRecoilSnapshot:Zd,useRecoilState:Bd,useRecoilStateLoadable:Pd,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Kd,useRecoilStoreID:gd,useRecoilTransactionObserver_UNSTABLE:Yd,useRecoilTransaction_UNSTABLE:jd,useRecoilValue:kd,useRecoilValueLoadable:Dd,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Wd,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Gd,useResetRecoilState:xd,useRetain:Jd,useSetRecoilState:Od,waitForAll:Ud,waitForAllSettled:Id,waitForAny:Md,waitForNone:$d},Symbol.toStringTag,{value:"Module"}));export{Ad as R,I as a,Td as b,Bd as c,kd as d,nf as e,yd as f,md as g,Od as h,Hd as i,pd as j,Ed as k,wd as l,Dd as m};
